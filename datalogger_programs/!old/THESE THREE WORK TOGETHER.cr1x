'MS3 Code
Public BP 'Barometric pressure
Public RH 'Relative humidity
Public AirTemp 'Air temperature
Public DP  'Dewpoint
Public MetSENS_Status As Long 'Status code of MetSENS
Dim MSData(9)
Dim N(9) As Long

Public BattV
Public PTemp

Alias N(1)=Good_Sample 'No fault, good samples
Alias N(2)=Fault_Wind 'Wind fault
Alias N(3)=Fault_Temperature 'Temperature fault
Alias N(4)=Fault_Dewpoint 'Dewpoint fault
Alias N(5)=Fault_Humidity 'Humidity fault
Alias N(6)=Fault_Pressure 'Pressure sensor warning
Alias N(7)=Fault_Compass 'Compass fault
Alias N(8)=Fault_Undefined  'Undefined fault
Alias N(9)=Fault_Checksum 'Checksum error

Units BP = hPa
Units RH = %
Units AirTemp = Deg C
Units DP = Deg C
Units MetSENS_Status=unitless

Units BattV= V
Units PTemp= Deg C

'MS3 Define Data Tables
DataTable (MS3_FifteenMin,True,-1 ) 'MS3 Fifteen minute data table
  DataInterval (0,15,Min,10)
  Sample (1,BP,IEEE4)
  Sample (1,RH,FP2)
  Average (1,AirTemp,FP2,AirTemp = NAN)
  Sample (1,DP,FP2)
  Sample (1,MetSENS_Status,Long)
  Totalize (1,Good_Sample,Long,False)
EndTable

DataTable (MS3_Hour,True,-1 ) 'MS3 Hour data table
  DataInterval (0,60,Min,10)
  Sample (1,BP,IEEE4)
  Sample (1,RH,FP2)
  Average (1,AirTemp,FP2,AirTemp = NAN)
  Sample (1,DP,FP2)
  Sample (1,MetSENS_Status,Long)
  Totalize (1,Good_Sample,Long,False)
EndTable

DataTable(MS3_Day,True,-1) 'MS3 Day data table (60*24 = 1440)
  DataInterval(0,1440,Min,10)
  Maximum (1,AirTemp,FP2,AirTemp = NAN,True)
  Minimum (1,AirTemp,FP2,AirTemp = NAN,True)
  Sample (1,PTemp,FP2)
  Minimum(1,BattV,FP2,False,False)
EndTable

'IMU Something
Dim IMUVector(16)
Alias IMUVector(1) = fAccelX
Alias IMUVector(2) = fAccelY
Alias IMUVector(3) = fAccelZ
Alias IMUVector(4) = fAngRateX
Alias IMUVector(5) = fAngRateY
Alias IMUVector(6) = fAngRateZ
Alias IMUVector(7) = fRoll
Alias IMUVector(8) = fPitch
Alias IMUVector(9) = fYaw
Alias IMUVector(10) = fQ1
Alias IMUVector(11) = fQ2
Alias IMUVector(12) = fQ3
Alias IMUVector(13) = fQ4
Alias IMUVector(14) = fGX
Alias IMUVector(15) = fGY
Alias IMUVector(16) = fGZ
Units fAccelX = g
Units fAccelY = g
Units fAccelZ = g
Units fAngRateX = rad/s
Units fAngRateY = rad/s
Units fAngRateZ = rad/s
Units fRoll = rad
Units fPitch = rad
Units fYaw = rad
Units fQ1 = unitless
Units fQ2 = unitless
Units fQ3 = unitless
Units fQ4 = unitless
Units fGX = g
Units fGY = g
Units fGZ = g

Dim dLat as Double
Dim dLon as Double
Dim dHEllipsoid as Double
Dim dHMSL as Double
Dim fHAccuracy as Float
Dim fVAccuracy as Float
Dim iValidFlags as Float

Const GX5_BUFFER = 300
Const IMU_RESPONSE_SIZE = 80
Const GPS_RESPONSE_SIZE = 50
Const GX5_RESPONSE_SIZE = IMU_RESPONSE_SIZE + GPS_RESPONSE_SIZE
Dim sGX5Buffer As String * GX5_BUFFER
Dim sGX5ComBuffer As String * GX5_BUFFER

'Windspeed Data:
Dim WSVector(4)
Alias WSVector(1) = fWSV1
Alias WSVector(2) = fWSV2
Alias WSVector(3) = fWSV3
Alias WSVector(4) = fWSC
Units fWSV1 = m/s
Units fWSV2 = m/s
Units fWSV3 = m/s
Units fWSC = DegC

Const WS_BUFFER = 80
Const WS_RESPONSE_SIZE = 37
Dim sWSBuffer As String * WS_BUFFER
Dim iWSDiag As Long
Dim iWSValue As Long

'Timing constants: check carefully
Const SCAN_PERIOD_MS = 25
Const IMU_PERIOD_MS = 100
Const GPS_PERIOD_MS = 1000
Const WS_PERIOD_MS = 50

DataTable(IMUTable, True, -1)
    CardOut(1, -1)
    DataInterval(0, IMU_PERIOD_MS, msec, 0)
    Sample(16, fAccelX, IEEE4)
EndTable

DataTable(GPSTable, True, -1)
    CardOut(1, -1)
    DataInterval(0, GPS_PERIOD_MS, msec, 0)
    Sample(1, dLat, IEEE8)
    Sample(1, dLon, IEEE8)
    Sample(1, dHEllipsoid, IEEE8)
    Sample(1, dHMSL, IEEE8)
    Sample(1, fHAccuracy, IEEE4)
    Sample(1, fVAccuracy, IEEE4)
    Sample(1, iValidFlags, Long)
EndTable

DataTable(WSTable, True, -1)
    CardOut(1, -1)
	DataInterval(0, WS_PERIOD_MS, msec, 0)
    Sample(4, fWSV1, IEEE4)
	Sample(1, iWSDiag, Long)
	Sample(1, iWSValue, Long)
EndTable

Dim iNGX5Ready As Long
Dim iGX5WriteIndex As Long
Dim iGX5Payload As Long
Dim iNIMUReads As Long
Dim iNGPSReads As Long
Dim iNIMU_GPSReads As Long
Dim iNGPS_IMUReads As Long
Dim iNBothErrors As Long
Dim iNGX5Errors As Long
Dim iNChkErrors As Long
Dim iIMUChecksum1 As Long
Dim iIMUChecksum2 As Long
Dim iGPSChecksum1 As Long
Dim iGPSChecksum2 As Long
Dim iNWSRead As Long
DataTable(DebugTable, True, -1)
    CardOut(1, -1)
    DataInterval(0, GPS_PERIOD_MS, msec, 0)
    Sample(1, iNGX5Ready, Long)
    Sample(1, iGX5WriteIndex, Long)
    Sample(1, iGX5Payload, Long)
    Sample(1, iNIMUReads, Long)
    Sample(1, iNGPSReads, Long)
    Sample(1, iNIMU_GPSReads, Long)
    Sample(1, iNGPS_IMUReads, Long)
    Sample(1, iNBothErrors, Long)
    Sample(1, iNGX5Errors, Long)
    Sample(1, iNChkErrors, Long)
    Sample(1, iIMUChecksum1, Long)
    Sample(1, iIMUChecksum2, Long)
    Sample(1, iGPSChecksum1, Long)
    Sample(1, iGPSChecksum2, Long)
    'Sample(1, iNWSRead, Long)
EndTable

Function FletcherChecksum(iOffset As Long, iNBytes As Long) As Long
    Dim sum(3) As Long
    Dim i As Long

    sum(1) = 0
    sum(2) = 0
    For i = 0 To (iNBytes - 1)
        MoveBytes(sum(3), 3, sGX5Buffer, iOffset + i, 1)
        sum(1) += sum(3)
        sum(2) += sum(1)
    Next i

    sum(1) = (sum(1) MOD 256) << 8
    sum(2) = sum(2) MOD 256
    Return sum(1) + sum(2)
EndFunction

Function ParseIMU(iOffset As Long)
    iIMUChecksum1 = FletcherChecksum(iOffset, IMU_RESPONSE_SIZE - 2)
    MoveBytes(iIMUChecksum2, 2, sGX5Buffer, iOffset + IMU_RESPONSE_SIZE - 2, 2)
    if (iIMUChecksum1 = iIMUChecksum2) Then
        'Move data to floats: field payload is data bytes + 2
        MoveBytes(fAccelX, 0, sGX5Buffer, iOffset + 6, 12)      '04, 14 byte payload
        MoveBytes(fAngRateX, 0, sGX5Buffer, iOffset + 20, 12)   '05, 14 byte payload
        MoveBytes(fRoll, 0, sGX5Buffer, iOffset + 34, 12)       '0C, 14 byte payload
        MoveBytes(fQ1, 0, sGX5Buffer, iOffset + 48, 16)         '0A, 18 byte payload
        MoveBytes(fGX, 0, sGX5Buffer, iOffset + 66, 12)         '11, 14 byte payload
    Else
        iNChkErrors = iNChkErrors + 1
    EndIf
EndFunction

Function ParseGPS(iOffset As Long)
    iGPSChecksum1 = FletcherChecksum(iOffset, GPS_RESPONSE_SIZE - 2)
    MoveBytes(iGPSChecksum2, 2, sGX5Buffer, iOffset + GPS_RESPONSE_SIZE - 2, 2)
    if (iGPSChecksum1 = iGPSChecksum2) Then
        'Move data to floats: field payload is data bytes + 2
        MoveBytes(dLat, 0, sGX5Buffer, iOffset + 6, 8)
        MoveBytes(dLon, 0, sGX5Buffer, iOffset + 14, 8)
        MoveBytes(dHEllipsoid, 0, sGX5Buffer, iOffset + 22, 8)
        MoveBytes(dHMSL, 0, sGX5Buffer, iOffset + 30, 8)
        MoveBytes(fHAccuracy, 0, sGX5Buffer, iOffset + 38, 4)
        MoveBytes(fVAccuracy, 0, sGX5Buffer, iOffset + 42, 4)
        MoveBytes(iValidFlags, 2, sGX5Buffer, iOffset + 46, 2)
    Else
        iNChkErrors = iNChkErrors + 1
    EndIf
EndFunction

Function GX5Byte(iOffset As Long) As Long
    Dim iReturn As Long
    MoveBytes(iReturn, 3, sGX5Buffer, iOffset, 1)
    Return iReturn
EndFunction

'Main Program
BeginProg

    'GX5 is on RS-232 ... check buffer sizes...
	SerialOpen(COMC7, 115200, 3, 0, GX5_BUFFER, 0)
	SerialOpen(32, 9600, 16, 0, WS_BUFFER, 0)

    'For debug output:
	'SerialOpen(COMC5, 9600, 3, 0, GX5_BUFFER, 0)

    'Main loop:
    iGX5WriteIndex = 0
    iNIMUReads = 0
    iNGPSReads = 0
    iNIMU_GPSReads = 0
    iNGPS_IMUReads = 0
    iNBothErrors = 0
    iNGX5Errors = 0
	Scan(SCAN_PERIOD_MS, msec, 2, 0)

        iNGX5Ready = SerialInChk(COMC7)
        If (iNGX5Ready <> 0) Then
            SerialInBlock(COMC7, sGX5ComBuffer, iNGX5Ready)
            If (iGX5WriteIndex + iNGX5Ready > GX5_RESPONSE_SIZE) Then
                iGX5WriteIndex = 0
                iNGX5Errors = iNGX5Errors + 1
            Else
                MoveBytes(sGX5Buffer, iGX5WriteIndex, sGX5ComBuffer, 0, iNGX5Ready)
                iGX5WriteIndex = iGX5WriteIndex + iNGX5Ready

                'Enough bytes to look? GPS is the smaller response.
                If (iGX5WriteIndex >= GPS_RESPONSE_SIZE) Then
                    'Response: 75 65 DD LL: Confirm 75 65
                    If (GX5Byte(0) <> &h75) OR (GX5Byte(1) <> &h65) Then
                        iGX5WriteIndex = 0
                        iNGX5Errors = iNGX5Errors + 1
                    Else
                        '75 65 DD LL -> fourth byte has payload size
                        iGX5Payload = GX5Byte(3)

                        'Got just the IMU payload:
                        If (iGX5WriteIndex = IMU_RESPONSE_SIZE) AND (iGX5Payload = IMU_RESPONSE_SIZE - 6) Then
                            ParseIMU(0)
                            iGX5WriteIndex = 0
                            iNIMUReads = iNIMUReads + 1

                        'Got just the GPS payload:
                        Else If (iGX5WriteIndex = GPS_RESPONSE_SIZE) AND (iGX5Payload = GPS_RESPONSE_SIZE - 6) Then
                            ParseGPS(0)
                            iGX5WriteIndex = 0
                            iNGPSReads = iNGPSReads + 1

                        'Got both payloads: see which is first
                        Else If (iGX5WriteIndex = GX5_RESPONSE_SIZE) Then
                            If (iGX5Payload = IMU_RESPONSE_SIZE - 6) Then
                                ParseIMU(0)
                                ParseGPS(IMU_RESPONSE_SIZE)
                                iNIMU_GPSReads = iNIMU_GPSReads + 1
                            Else If (iGX5Payload = GPS_RESPONSE_SIZE - 6) Then
                                ParseGPS(0)
                                ParseIMU(GPS_RESPONSE_SIZE)
                                iNGPS_IMUReads = iNGPS_IMUReads + 1
                            Else
                                iNBothErrors = iNBothErrors + 1
                            EndIf

                            iGX5WriteIndex = 0
                        EndIf
                    EndIf
                EndIf
            EndIf
        EndIf

		'WS parsing: using checksum
		SerialInRecord(32, sWSBuffer, &h02, 0, &h0D0A, iNWSRead, 00)
        If (iNWSRead = WS_RESPONSE_SIZE) Then
		    If HexToDec(Mid(sWSBuffer, 36, 2)) = CheckSum(sWSBuffer, 9, 34) Then
                iWSDiag = Mid(sWSBuffer, 1, 2)
                iWSValue = Mid(sWSBuffer, 4, 2)
                fWSV1 = Mid(sWSBuffer, 7, 6)
                fWSV2 = Mid(sWSBuffer, 14, 6)
                fWSV3 = Mid(sWSBuffer, 21, 6)
                fWSC = Mid(sWSBuffer, 28, 6)
            EndIf
        EndIf

        'Update tables for IMU and HS50
        CallTable IMUTable
        CallTable GPSTable
		    CallTable WSTable
        CallTable DebugTable
'Main Scan
NextScan
SlowSequence
Scan(3,Sec,1,0) 'MetSENS300 needs at least 3 seconds of measurement time
    'Default CR1000X Datalogger Battery Voltage measurement 'BattV'
    Battery(BattV)
    'Default CR1000X Datalogger Wiring Panel Temperature measurement 'PTemp'
    PanelTemp(PTemp,60)

    'MetSENS300 multiparameter weather sensor
    SDI12Recorder (MSData(1),C5,0,"MC1!",1.0,0,9)
    AirTemp=MSData(1)
    RH=MSData(2)
    DP=MSData(3)
    BP=MSData(4)
    MetSENS_Status=MSData(5)

    ' Set diagnostic variables as needed
    Move(Good_Sample,9,0,1)
    Select Case MetSENS_Status
    Case=0
      Good_Sample=1
    Case=1
      Fault_Wind=1
    Case=10
      Fault_Temperature=1
    Case=20
      Fault_Dewpoint=1
    Case=40
      Fault_Humidity=1
    Case=80
      Fault_Pressure=1
    Case=100
      Fault_Compass=1
    Else
      Fault_Undefined=1
    EndSelect

    'Call Data Tables and Store Data for the MS3
    CallTable MS3_FifteenMin
    CallTable MS3_Hour
    CallTable MS3_Day
	NextScan
EndProg

'IMU Data:
'Linear Accel: Scaled Accelerometer Vector (0x80, 0x04), g, 14 bytes
'Angular Rate: Scaled Gyro Vector (0x80, 0x05), rad/sec, 14 bytes
'Euler Angles: CF Euler angles (0x80, 0x0C), RPY, rad, 14 bytes
'Quaternion: CF Quaternion (0x80, 0x0A), 18 bytes
'Gravity Vector: CF Stabilized Up Vector (0x80, 0x11), 14 bytes
'
'That's 6 + 14 + 14 + 14 + 18 + 14 = 80 bytes (includes checksum)
'At 20Hz that's 1600 Bps or 16,000 bps
'
'GPS Data: (collected with IMU at slower rate)
'GNSS Data: LLH Position: (0x81, 0x03), 44 bytes
'
'That's 6 + 32 = 38?? 50 bytes
'Together, both IMU and GPS responses are 130 bytes total
'MS3 Declare Variables and Units
